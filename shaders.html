<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Shaders</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Shaders</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="shaders.html" class="active">Shaders</a></li>
						<li><a href="nerf.html">NeRF</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Genshin Shaders</h1>
							<span class="image fit"><img src="images/Pencil.png" alt="" /></span>
							<p>The first part of our project was to create custom shaders for Genshin Impact, and we broke down this task into multiple parts:</p>
							<ul>
								<li>Injecting Shaders into Genshin Impact</li>
								<li>Creating the Kuwahara Filters</li>
								<li>Creating the Noir Shaders</li>
								<li>Creating the Cel Shaders</li>
								<li>Creating the Anime/Manga Shaders</li>
							</ul>
							<h3>Injecting Shaders into Genshin Impact</h3>
							<p>In order to do this, we first needed to find a way to inject shaders into the game. Shaders are part of the rendering pipeline that most games do not expose to the end user, as game developers generally do not want the end user to make any modifications to their game. Such modifications are protected through the use of Anti-Cheat systems. Genshin Impact has an anti-cheat built in, and we found a way to bypass the anti-cheat and inject our own shaders.
							</p>
							<p>We were able to find the <a href="https://github.com/sefinek24/Genshin-Impact-ReShade">Genshin-Impact-ReShade</a> repository on GitHub that accomplished this exact task, and upon installation onto a Windows machine, we were able to inject the built-in shaders.</p>
							<p>These shaders are written using <a href="https://reshade.me/">ReShade FX</a>, which is a shading language and compiler whose syntax is very closely related to HLSL.</p>
							<p>To avoid getting Levy's actual Genshin Impact account from being banned, Levy created a new account for this project.</p>
							
							<h3>Creating the Kuwahara Filters</h3>
							<p>The first shader that we tackled was the Kuwahara Filter. The Kuwahara filter creates a painting-like flattening effect along the local feature directions, while preserving shape boundaries. This approach preserves edges, and we chose this approach over bilateral filters and mean shift filters due to its effectiveness over high and low contrast images. We created three different versions of the Kuwahara Filter: one based on square quadrants, one based on circular kernels, and one based on anisotropic kernels.</p>
							<p>To create the Kuwahara filter based on square quadrants, we create a square filter that has four square quadrants that are each radius by radius large and overlap by one pixel, which is the current pixel that is being processed.</p>
							<img src="images/square filters.png" height="25%">
							<p>First, we calculate the following:</p>
							<img src="images/square wk.png" height="25%">
							<p>|W_k| is equivalent to the number of pixels in the quadrant we are computing, with r defined as radius.</p>
							<p>Then, using the previous definition, we calculate the mean, m_k as the following:</p>
							<img src="images/square mean.png" height="25%">
							<p>We calculate the variance as the average of the square of the distance of each pixel to the mean, as the following:</p>
							<img src="images/square variance.png" height="25%">
							<p>In this model, we assume that the variances for each channel color do not correlate with each other, so this means that the final variance for W_k is going to be the following:</p>
							<img src="images/square final var.png" height="25%">
							<p>Now, the output value for our pixel at (x0, y0) is goint to be:</p>
							<img src="images/square result.png" height="25%">
							<p><a href="https://github.com/ld184/CS184-Final-Project/blob/main/src/KuwaharaSquare.fx">Here</a> is the source code for our implementation of the Kuwahara filter based on square quadrants.</p>

							<p>Next, we created the Kuwahara filter based on circular kernels. We first created different sectors of the circular filter that we were going to implement at a time, and this is adjacent to the idea of the square quadrants of the Kuwahara filter that uses the square quadrants. First, we calculate sigma_r and sigma_s to be the following, where the circular kernel's radius, K_size, is defined to be 32:</p>
							<img src="images/circle sigma r sigma s.png">
							<p>Then, we can calculate gaussians using standard deviations with sigma_r and sigma_s using the following formula:</p>
							<img src="images/circle g_sigma.png">
							<p>Next, we can define our smooth weighting function w_k using the following formula:</p>
							<img src="images/circle wk.png">
							<p>Here, the x_k value is convolved with the gaussian that uses standard deviation of sigma_s, then the result is multiplied by sigma_r.</p>
							<p>Now, the weighted mean m_k at a point (x0, y0) is defined as the following:</p>
							<img src="images/circle mk.png">
							<p>The convolution smooths the characteristic function such that the characteristic functions slightly overlap with one another. Also, notice how the sum of w_k is equivalent to a Gaussian filter, so this is why the mean m_k is calculated above.</p>
							<p>Now, the weighted variance is defined as the following:</p>
							<img src="images/circle sk.png">
							<p>The output of our filter is a weighted average of the means with the variances. To refine our weighted average, we define alpha_k to be the following:</p>
							<img src="images/circle alpha k.png">
							<p>The final output for a pixel (x0, y0) is the following:</p>
							<img src="images/circle f x0 y0.png">
							<br>
							<p>To implement this, w_k is actually fairly hard to compute, since computing it requires convolutions. Instead of computing w_k for every pixel, one at a time, we create a texture map that we can use to sample w_k that uses bilinear interpolation. Furthermore, since each sector of a circle is equivalent to one sector, rotated multiple times, so the w_k value will be calculated with the following function:</p>
							<img src="images/circle wk x y.png">

							<p>To sample a texture to get w_k, we created a compute shader dynamically using generated gaussian values. We call this texture K0.</p>
							<p><a href="https://github.com/ld184/CS184-Final-Project/blob/main/src/KuwaharaCircle.fx">Here</a> is the source code for our implementation of the Kuwahara filter based on square quadrants.</p>
						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Untitled. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>