<!DOCTYPE HTML>
<!--
	Hyperspace by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Shaders</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">

		<!-- Header -->
			<header id="header">
				<a href="index.html" class="title">Shaders</a>
				<nav>
					<ul>
						<li><a href="index.html">Home</a></li>
						<li><a href="shaders.html" class="active">Shaders</a></li>
						<li><a href="nerf.html">NeRF</a></li>
					</ul>
				</nav>
			</header>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<section id="main" class="wrapper">
						<div class="inner">
							<h1 class="major">Genshin Shaders</h1>
							<span class="image fit"><img src="images/Pencil.png" alt="" /></span>
							<p>The first part of our project was to create custom shaders for Genshin Impact, and we broke down this task into multiple parts:</p>
							<ul>
								<li><a href="#injecting">Injecting Shaders into Genshin Impact</a></li>
								<li><a href="#kuwahara">Creating the Kuwahara Filters</a></li>
								<li><a href="#noir">Creating the Noir Shaders</a></li>
								<li><a href="#cel">Creating the Cel Shaders</a></li>
							</ul>
							<h3 id="injecting">Injecting Shaders into Genshin Impact</h3>
							<p>In order to do this, we first needed to find a way to inject shaders into the game. Shaders are part of the rendering pipeline that most games do not expose to the end user, as game developers generally do not want the end user to make any modifications to their game. Such modifications are protected through the use of Anti-Cheat systems. Genshin Impact has an anti-cheat built in, and we found a way to bypass the anti-cheat and inject our own shaders.
							</p>
							<p>We were able to find the <a href="https://github.com/sefinek24/Genshin-Impact-ReShade">Genshin-Impact-ReShade</a> repository on GitHub that accomplished this exact task, and upon installation onto a Windows machine, we were able to inject the built-in shaders.</p>
							<p>These shaders are written using <a href="https://reshade.me/">ReShade FX</a>, which is a shading language and compiler whose syntax is very closely related to HLSL.</p>
							<p>To avoid getting Levy's actual Genshin Impact account from being banned, Levy created a new account for this project.</p>
							
							<h3 id="kuwahara">Creating the Kuwahara Filters</h3>
							<p>The first shader that we tackled was the Kuwahara Filter. The Kuwahara filter creates a painting-like flattening effect along the local feature directions, while preserving shape boundaries. This approach preserves edges, and we chose this approach over bilateral filters and mean shift filters due to its effectiveness over high and low contrast images. We created three different versions of the Kuwahara Filter: one based on square quadrants, one based on circular kernels, and one based on anisotropic kernels.</p>

							<h4>Kuwahara Filter Based on Square Quadrants</h4>
							<p>To create the Kuwahara filter based on square quadrants, we create a square filter that has four square quadrants that are each radius by radius large and overlap by one pixel, which is the current pixel that is being processed.</p>
							<img src="images/square filters.png" height="25%">
							<p>First, we calculate the following:</p>
							<img src="images/square wk.png" height="25%">
							<p>|W_k| is equivalent to the number of pixels in the quadrant we are computing, with r defined as radius.</p>
							<p>Then, using the previous definition, we calculate the mean, m_k as the following:</p>
							<img src="images/square mean.png" height="25%">
							<p>We calculate the variance as the average of the square of the distance of each pixel to the mean, as the following:</p>
							<img src="images/square variance.png" height="25%">
							<p>In this model, we assume that the variances for each channel color do not correlate with each other, so this means that the final variance for W_k is going to be the following:</p>
							<img src="images/square final var.png" height="25%">
							<p>Now, the output value for our pixel at (x0, y0) is goint to be:</p>
							<img src="images/square result.png" height="25%">
							<p><a href="https://github.com/ld184/CS184-Final-Project/blob/main/src/KuwaharaSquare.fx">Here</a> is the source code for our implementation of the Kuwahara filter based on square quadrants.</p>
							<p>Here is a comparison between the base shaders with the square kuwahara shader.</p>
							<span class="image fit"><img src="images/Normal.png"></span>
							<span class="image fit"><img src="images/KuwaSquared.png"></span>

							<h4>Kuwahara Filter Based on Circular Kernels</h4>
							<p>Next, we created the Kuwahara filter based on circular kernels. We first created different sectors of the circular filter that we were going to implement at a time, and this is adjacent to the idea of the square quadrants of the Kuwahara filter that uses the square quadrants. First, we calculate sigma_r and sigma_s to be the following, where the circular kernel's radius, K_size, is defined to be 32:</p>
							<img src="images/circle sigma r sigma s.png">
							<p>Then, we can calculate gaussians using standard deviations with sigma_r and sigma_s using the following formula:</p>
							<img src="images/circle g_sigma.png">
							<p>Next, we can define our smooth weighting function w_k using the following formula:</p>
							<img src="images/circle wk.png">
							<p>Here, the x_k value is convolved with the gaussian that uses standard deviation of sigma_s, then the result is multiplied by sigma_r.</p>
							<p>Now, the weighted mean m_k at a point (x0, y0) is defined as the following:</p>
							<img src="images/circle mk.png">
							<p>The convolution smooths the characteristic function such that the characteristic functions slightly overlap with one another. Also, notice how the sum of w_k is equivalent to a Gaussian filter, so this is why the mean m_k is calculated above.</p>
							<p>Now, the weighted variance is defined as the following:</p>
							<img src="images/circle sk.png">
							<p>The output of our filter is a weighted average of the means with the variances. To refine our weighted average, we define alpha_k to be the following:</p>
							<img src="images/circle alpha k.png">
							<p>The final output for a pixel (x0, y0) is the following:</p>
							<img src="images/circle f x0 y0.png">
							<br>
							<p>To implement this, w_k is actually fairly hard to compute, since computing it requires convolutions. Instead of computing w_k for every pixel, one at a time, we create a texture map that we can use to sample w_k that uses bilinear interpolation. Furthermore, since each sector of a circle is equivalent to one sector, rotated multiple times, so the w_k value will be calculated with the following function:</p>
							<img src="images/circle wk x y.png">

							<p>To sample a texture to get w_k, we created a compute shader dynamically using gaussian values that we generate on the fly. We call this texture K0.</p>
							<p><a href="https://github.com/ld184/CS184-Final-Project/blob/main/src/KuwaharaCircle.fx">Here</a> is the source code for our implementation of the Kuwahara filter based on square quadrants.</p>
							
							<p>Here is a comparison between the base shaders with the circular kuwahara shader.</p>
							<span class="image fit"><img src="images/Normal.png"></span>
							<span class="image fit"><img src="images/KuwaCircle.png"></span>

							<h4>Kuwahara Filter Based on Anisotropic Kernels</h4>
							<p>Finally, we implemented the hardest version of the Kuwahara filter, which is the Kuwahara filter with anisotropic kernels. In comparison to the kuwahara filter with circular kernels, the Kuwahara filter with anisotropic kernels changes the shape of the circle so that the circle can stretch and shrink in different directions so that the resulting ellipse's principal direction matches with the direction of the image's features. For instance, the pixel that we are sampling is at an edge, the circle will become an ellipse so that the principle direction of the ellipse will be along the edge.</p>
							<p>This filter is by far the hardest to implement.</p>
							<p>To accomplish this, we process the image at each pixel into multiple stages, as follows:</p>
							<img src="images/aniso flow.png">
							<p>This means that we first calculate the structure tensor, then compute the gaussian filter and orientation/anisotropy, and finally filter and return the result.</p>
							
							<p>The first step is to calculate the structure tensor from the RGB values of the input. If we let f be the input image, then S_x and S_y are the horizontal and vertical convolution masks of the Sobel edge detection filter:</p>
							<img src="images/aniso sx sy.png">
							<p>The approximations of the partial derivaties of f are defined by the following: f_x = S_x convolved with f and f_y = S_y convolved with f.</p>
							<img src="images/aniso fx fy.png">
							<p>Now, the structural tensor of f is defined as follows:</p>
							<img src="images/aniso gij.png">
							<p>To get the structural tensor's eigenvalues and the eigenvector of the minimum rate of change, we do the following:</p>
							<img src="images/aniso l1 l2.png">
							<img src="images/aniso t.png">
							<p>Now, the angle by which the ellipse is rotated is the following:</p>
							<img src="images/aniso phi.png">
							<p>We calculate the measure of anisotropy to be the following, with 0 being isotropic and 1 being entirely anisotropic.</p>
							<img src="images/aniso a.png">
							<br>

							<p>The next step is to compute the gaussian filter and orientation/anisotropy.</p>
							<p>Recall that the equation of the rotated ellipse is the following:</p>
							<img src="images/aniso rotated ellipse.png">
							<p>Once we write this equation in standard form and plug in the values into the equation, we get the following:</p>
							<img src="images/aniso p x y.png">
							<img src="images/aniso abcdef.png">
							<p>We calculate the horizontal extrema where the partial derivative in the y direction vanishes to be as follows:</p>
							<img src="images/aniso dp dy.png">
							<p>After we substitute this value of y into the ellipse, we get the equation:</p>
							<img src="images/aniso a minus e2.png">
							<p>This ellipse's horizontal and vertical extrema are as follows:</p>
							<img src="images/aniso x.png">
							<img src="images/aniso y.png">
							<p>If we want to adjust the ellipse's eccentricity, or how flat/round the ellipse's shape is, we can introduce a new variable called α. With a very large α value, the a and b axes converge to 1, and with α = 1, we have a maximum eccentricity of 4. The values a and b are governed by this formula:</p>
							<img src="images/aniso a b.png">
							<p>Now, to get the value w_k(x, y), we sample from the texture K0 that is defined in the above section using circular filters to get the following:</p>
							<img src="images/aniso wk x y.png">
							<p>Note that in order to calculate w_k, we need the formula for S, which is:</p>
							<img src="images/aniso s.png">
							<p>Also note that S * R matrix maps points from the ellipse to a circle of radius 0.5.</p>

							<p>We then apply the same logic as in the circular filter to compute the result of the filter.</p>
							<p><a href="https://github.com/ld184/CS184-Final-Project/blob/main/src/Kuwahara.fx">Here</a> is the source code for our implementation of the Kuwahara filter based on square quadrants.</p>

							<h3 id="noir">Creating the Noir Shaders</h3>
							<p>In order to compute the noir shaders, we first need to determine whether a pixel is along an edge. We do this by implementing the sobel filter, and if the value output by the sobel filter is greater than a threshold, we can say that the pixel is along an edge. We compute that as follows:</p>
							<img src="images/noir sobel.png">
							<p>Here, note that the G_x and G_y are the horizontal and vertical derivative approximations, and A is the source image. The two matrices are each convolved with the source image A.</p>
							<p>Using these approximations, we calculate the gradient as follows:</p>
							<img src="images/noir gradient.png">
							<p>If the gradient is greater than a variable called EdgeSlope which we have set to 0.23, we consider this pixel to be along an edge.</p>
							<p>For pixels along an edge, we draw a white pixel and set the opacity value to be very high.</p>
							<p>Otherwise, we color in the pixel value with a pencil texture, based on the average color channel's intensity value, 0.33 * (r + g + b).</p>
							<p>TODO: WRITE ABOUT THE PENCIL TEXTURE</p>

							<p>Here is a comparison between the base shaders with the noir pencil shader.</p>
							<span class="image fit"><img src="images/Normal.png"></span>
							<span class="image fit"><img src="images/Pencil.png"></span>

							<h3 id="cel">Creating the Cel Shaders</h3>
							<p>TODO: write description about how the cel shaders were created</p>

							<p>Here is a comparison between the base shaders with the cel shader.</p>
							<span class="image fit"><img src="images/Normal.png"></span>
							<span class="image fit"><img src="images/Cel.png"></span>

						</div>
					</section>

			</div>

		<!-- Footer -->
			<footer id="footer" class="wrapper alt">
				<div class="inner">
					<ul class="menu">
						<li>&copy; Untitled. All rights reserved.</li><li>Design: <a href="http://html5up.net">HTML5 UP</a></li>
					</ul>
				</div>
			</footer>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>